-- Store for dynamic button nodes
local plane_buttons = {}
local popup_visible = false
local current_route = nil
local close_hover = false

function init(self)
    -- Hide the popup initially
    gui.set_enabled(gui.get_node("popup_container"), false)
    
    -- Also hide all text nodes
    gui.set_enabled(gui.get_node("popup_title"), false)
    gui.set_enabled(gui.get_node("popup_distance"), false)
    gui.set_enabled(gui.get_node("popup_airports"), false)
    gui.set_enabled(gui.get_node("popup_categories"), false)
    gui.set_enabled(gui.get_node("popup_aircraft_title"), false)
    gui.set_enabled(gui.get_node("close_button"), false)
    
    -- Initialize state variables
    self.plane_buttons = {}
    self.popup_visible = false
    self.current_route = nil
    self.close_hover = false
    
    -- Acquire input focus to handle clicks
    msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message, sender)
    if message_id == hash("show_route_popup") then
        -- Handle showing the route popup
        show_route_popup(self, message)
    elseif message_id == hash("hide_route_popup") then
        -- Handle hiding the route popup
        hide_route_popup(self)
    end
end

function show_route_popup(self, message)
    -- Store route data
    self.current_route = {
        airport1 = message.airport1,
        airport2 = message.airport2,
        distance = message.distance,
        valid_categories = message.valid_categories,
        eligible_planes = message.eligible_planes
    }
    
    -- Update popup title
    local title_node = gui.get_node("popup_title")
    gui.set_text(title_node, "Route: " .. message.airport1.name .. " to " .. message.airport2.name)
    
    -- Update distance
    local distance_node = gui.get_node("popup_distance")
    gui.set_text(distance_node, "Distance: " .. string.format("%.0f", message.distance) .. " km")
    
    -- Update airport categories
    local airports_node = gui.get_node("popup_airports")
    local airport1_cat = message.airport1.category or 2
    local airport2_cat = message.airport2.category or 2
    gui.set_text(airports_node, "Airport Categories: " .. 
        message.airport1.name .. " (Cat " .. airport1_cat .. ") - " .. 
        message.airport2.name .. " (Cat " .. airport2_cat .. ")")
    
    -- Update valid plane categories
    local categories_node = gui.get_node("popup_categories")
    local categories_text = "Valid Plane Categories: "
    if #message.valid_categories > 0 then
        for i, cat in ipairs(message.valid_categories) do
            categories_text = categories_text .. cat
            if i < #message.valid_categories then
                categories_text = categories_text .. ", "
            end
        end
    else
        categories_text = categories_text .. "None"
    end
    gui.set_text(categories_node, categories_text)
    
    -- Create buttons for eligible planes
    create_plane_buttons(self, message.eligible_planes)
    
    -- Show the popup and all its elements
    gui.set_enabled(gui.get_node("popup_container"), true)
    gui.set_enabled(gui.get_node("popup_title"), true)
    gui.set_enabled(gui.get_node("popup_distance"), true)
    gui.set_enabled(gui.get_node("popup_airports"), true)
    gui.set_enabled(gui.get_node("popup_categories"), true)
    gui.set_enabled(gui.get_node("popup_aircraft_title"), true)
    gui.set_enabled(gui.get_node("close_button"), true)
    
    self.popup_visible = true
end

function create_plane_buttons(self, eligible_planes)
    -- Clear any existing buttons
    clear_plane_buttons(self)
    
    if not eligible_planes or #eligible_planes == 0 then
        -- No eligible planes message
        local no_planes_node = gui.new_text_node(vmath.vector3(683, 340, 0.1), "No suitable aircraft in your fleet for this route.")
        gui.set_font(no_planes_node, "Roboto-Regular")
        gui.set_color(no_planes_node, vmath.vector4(1, 1, 1, 1))
        table.insert(self.plane_buttons, {node = no_planes_node, hover = false})
        return
    end
    
    -- Create a button for each eligible plane
    local button_height = 30
    local button_spacing = 40
    local start_y = 340
    
    for i, plane_data in ipairs(eligible_planes) do
        local y_pos = start_y - (i-1) * button_spacing
        
        -- Create button background
        local button_node = gui.new_box_node(
            vmath.vector3(683, y_pos, 0.1),
            vmath.vector3(350, button_height, 0)
        )
        gui.set_color(button_node, vmath.vector4(0.3, 0.3, 0.3, 1))
        
        -- Create text label
        local text_node = gui.new_text_node(
            vmath.vector3(683, y_pos, 0.11), 
            plane_data.plane.planeName .. " (x" .. plane_data.count .. ")"
        )
        gui.set_font(text_node, "Roboto-Regular")
        gui.set_color(text_node, vmath.vector4(1, 1, 1, 1))
        
        -- Add to button list with hover state and explicit index
        table.insert(self.plane_buttons, {
            node = button_node,
            text_node = text_node,
            hover = false,
            index = i,
            plane_data = plane_data  -- Store direct reference to the plane data
        })
    end
    
    -- Debug print for validation
    print("Created " .. #self.plane_buttons .. " plane buttons")
end

function clear_plane_buttons(self)
    -- Delete all existing plane buttons
    for _, button in ipairs(self.plane_buttons) do
        gui.delete_node(button.node)
        if button.text_node then
            gui.delete_node(button.text_node)
        end
    end
    self.plane_buttons = {}
end

function hide_route_popup(self)
    -- Hide the popup container and all text nodes
    gui.set_enabled(gui.get_node("popup_container"), false)
    gui.set_enabled(gui.get_node("popup_title"), false)
    gui.set_enabled(gui.get_node("popup_distance"), false)
    gui.set_enabled(gui.get_node("popup_airports"), false)
    gui.set_enabled(gui.get_node("popup_categories"), false)
    gui.set_enabled(gui.get_node("popup_aircraft_title"), false)
    gui.set_enabled(gui.get_node("close_button"), false)
    
    -- Clear buttons
    clear_plane_buttons(self)
    
    -- Reset state
    self.popup_visible = false
    self.current_route = nil
    self.close_hover = false
end

function on_input(self, action_id, action)
    if not self.popup_visible then
        return false
    end
    
    -- Check if the close button was clicked
    if action_id == hash("touch") and action.pressed then
        local close_node = gui.get_node("close_button")
        if gui.pick_node(close_node, action.x, action.y) then
            -- Send close message to the script
            msg.post("MapScreenScriptContainer#MapScreen", "close_popup")
            hide_route_popup(self)
            return true
        end
        
        -- Check if any plane button was clicked
        for _, button in ipairs(self.plane_buttons) do
            if gui.pick_node(button.node, action.x, action.y) then
                -- Send assign plane message to the script
                if button.plane_data then
                    -- Use direct reference if available
                    msg.post("MapScreenScriptContainer#MapScreen", "assign_plane", {
                        plane_data = button.plane_data
                    })
                elseif button.index and self.current_route and self.current_route.eligible_planes and self.current_route.eligible_planes[button.index] then
                    -- Fallback to index-based reference
                    msg.post("MapScreenScriptContainer#MapScreen", "assign_plane", {
                        plane_data = self.current_route.eligible_planes[button.index]
                    })
                else
                    print("Error: Unable to assign plane - missing data")
                end
                hide_route_popup(self)
                return true
            end
        end
    end
    
    -- Handle hover effects for close button
    if action_id == nil then
        local close_node = gui.get_node("close_button")
        local is_hovering = gui.pick_node(close_node, action.x, action.y)
        
        if is_hovering and not self.close_hover then
            -- Apply hover effect
            gui.set_color(close_node, vmath.vector4(1.0, 0.4, 0.4, 1.0))
            self.close_hover = true
        elseif not is_hovering and self.close_hover then
            -- Remove hover effect
            gui.set_color(close_node, vmath.vector4(0.8, 0.3, 0.3, 1.0))
            self.close_hover = false
        end
        
        -- Handle hover effects for plane buttons
        for _, button in ipairs(self.plane_buttons) do
            local is_hovering_plane = gui.pick_node(button.node, action.x, action.y)
            
            if is_hovering_plane and not button.hover then
                -- Apply hover effect
                gui.set_color(button.node, vmath.vector4(0.4, 0.4, 0.4, 1.0))
                button.hover = true
            elseif not is_hovering_plane and button.hover then
                -- Remove hover effect
                gui.set_color(button.node, vmath.vector4(0.3, 0.3, 0.3, 1.0))
                button.hover = false
            end
        end
    end
    
    return true
end