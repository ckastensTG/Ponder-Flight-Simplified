local dt=0
local airports = require("LocFiles.Map_Locs")
local airportList = {
	{ model = "Airport1#Airport", id = "Airport1", name = "Airport", category = 1 },
	{ model = "Airport2#Airport2", id = "Airport2", name = "Airport2", category = 2 },
	{ model = "Airport3#Airport3", id = "Airport3", name = "Airport3", category = 3 },
	{ model = "Airport4#Airport4", id = "Airport4", name = "Airport4", category = 3 },
}

-- Colors for selection states
local COLORS = {
	normal = vmath.vector4(1, 1, 1, 1),
	hover = vmath.vector4(1, 0.8, 0.5, 1),
	selected = vmath.vector4(1, 0.5, 0, 1),
	second_selected = vmath.vector4(0.8, 0.2, 0.2, 1),
	green = vmath.vector4(0, 1, 0, 1)
}

-- Globe diameter in km for distance calculations
local GLOBE_DIAMETER = 12000

-- Recommended line cylinder dimensions
-- Length: 1.0 (will be scaled by the distance)
-- Width/Diameter: 0.05 (thin enough to look like a line)
-- Height: 0.05 (same as width for a circular cross-section)

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_camera_projection")
	msg.post("camera", "acquire_camera_focus")
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	
	-- position directional light
	self.light = vmath.vector4(0, 0, go.get_position().z + 10, 0)
	local new_light = vmath.vector4(-0.5, -0.5, -0.5, 1.0)
	msg.post("@render:", "set_ambient_light", { color = new_light })
	go.set("Globe#GlobeModel", "light", self.light)
	go.set("Globe#GlobeModel", "tint", COLORS.green)

	-- Set light for each airport using a loop
	for _, airport in ipairs(airportList) do
		go.set(airport.model, "light", self.light)
		-- Set initial tint for each airport
		go.set(airport.model, "tint", COLORS.normal)
		
		-- Add selection and hover state
		airport.selected = false
		airport.hover = false
		
	end
	
	-- Initialize rotation speed
	self.rotation_speed = 90 -- degrees per second
	
	-- Enable collision detection for airports
	for _, airport in ipairs(airportList) do
		msg.post(airport.id .. "#collisionobject", "enable")
	end
	
	-- Initialize selected airports for route creation
	self.first_selected_airport = nil
	self.second_selected_airport = nil
	
	-- Initialize temporary route line
	self.route_line = nil
	
	-- Initialize popup-related variables
	self.popup_visible = false
	self.current_route = nil
	
	-- Initialize the array to track active route lines
	self.active_route_lines = {}
	
	-- Load the route popup GUI
	msg.post("RoutePopup#RoutePopup", "load")
end

-- Convert 3D world position to 2D screen position
function world_to_screen(world_pos)
	-- Handle nil input
	if not world_pos then
		return nil
	end
	
	-- Convert to vector3 if it's a table
	local pos = type(world_pos) == "userdata" and world_pos or 
		vmath.vector3(world_pos.x or world_pos[1] or 0, 
					 world_pos.y or world_pos[2] or 0, 
					 world_pos.z or world_pos[3] or 0)
	
	-- Camera is at (0,0,10) looking down negative Z axis
	local camera_pos = vmath.vector3(0, 0, 10)
	
	-- Calculate vector from camera to world position
	local to_pos = pos - camera_pos
	
	-- Simple perspective projection
	-- The farther away, the smaller the projection
	local distance = math.abs(to_pos.z)
	if distance < 0.1 then
		-- Avoid division by almost zero
		return nil
	end
	
	-- Get screen dimensions
	local screen_width = tonumber(sys.get_config("display.width"))
	local screen_height = tonumber(sys.get_config("display.height"))
	
	-- Default FOV for Defold camera is 0.7854 radians (45 degrees)
	local fov = 0.7854
	local scale = 1 / math.tan(fov/2)
	
	-- Project to screen space
	local screen_x = (to_pos.x / distance) * scale * screen_height/2 + screen_width/2
	local screen_y = (to_pos.y / distance) * scale * screen_height/2 + screen_height/2
	
	return vmath.vector3(screen_x, screen_y, 0)
end

-- Calculate the great circle distance between two 3D points on a sphere
function calculate_great_circle_distance(self, pos1, pos2)
	-- Normalize positions to get points on unit sphere
	local p1 = vmath.normalize(pos1)
	local p2 = vmath.normalize(pos2)
	
	-- Calculate the angle between the two vectors (in radians)
	local dot_product = vmath.dot(p1, p2)
	-- Clamp to [-1, 1] to avoid floating-point errors
	dot_product = math.max(-1, math.min(1, dot_product))
	local angle = math.acos(dot_product)
	
	-- Convert angle to distance using globe diameter
	-- Great circle distance = radius * central angle
	-- Circumference = 2 * pi * radius, and radius = diameter / 2
	-- So distance = (diameter / 2) * angle
	local radius = GLOBE_DIAMETER / 2
	local distance = radius * angle
	
	return distance
end

-- Create or update a line between selected airports
function update_route_line(self)
	-- Remove existing line if any
	if self.route_line then
		go.delete(self.route_line)
		self.route_line = nil
	end
	
	-- If we don't have two airports selected, don't draw anything
	if not self.first_selected_airport or not self.second_selected_airport then
		return
	end
	
	-- Get the positions of the two airports
	local pos1 = go.get_position(self.first_selected_airport.id)
	local pos2 = go.get_position(self.second_selected_airport.id)
	
	-- Create a line between the two positions (simplified for demonstration)
	-- In a real implementation, you might want to use a custom model or particle effect
	
	-- For demonstration, we'll create a simple factory-based line
	-- Alternatively, you could draw a series of points along the great circle path
	
	-- Create a dynamic game object for the line
	-- This is a placeholder - you would need to create a line factory
	-- self.route_line = factory.create("#line_factory", (pos1 + pos2) / 2, nil, {
	--    start = pos1,
	--    end = pos2,
	--    color = vmath.vector4(1, 1, 0, 1)
	-- })
	
	-- For now, just print the information
	local distance = calculate_great_circle_distance(self, pos1, pos2)
	print("Route Line: " .. self.first_selected_airport.name .. " to " .. self.second_selected_airport.name)
	print("Distance: " .. string.format("%.0f", distance) .. " km")
end

-- Display route information when two airports are selected
function show_route_info(self)
	if not self.first_selected_airport or not self.second_selected_airport then
		return
	end
	
	local pos1 = go.get_position(self.first_selected_airport.id)
	local pos2 = go.get_position(self.second_selected_airport.id)
	
	-- Calculate distance
	local distance = calculate_great_circle_distance(self, pos1, pos2)
	
	print("Route: " .. self.first_selected_airport.name .. " to " .. self.second_selected_airport.name)
	print("Distance: " .. string.format("%.0f", distance) .. " km")
	
	-- Get the airport categories
	local airport1_category = self.first_selected_airport.category or 2
	local airport2_category = self.second_selected_airport.category or 2
	
	print("Airport 1 Category: " .. airport1_category)
	print("Airport 2 Category: " .. airport2_category)

	-- Get valid plane categories and eligible planes
	local valid_categories = get_valid_plane_categories(airport1_category, airport2_category)
	local eligible_planes = get_eligible_fleet_planes(self, valid_categories, distance)
	
	-- Store the current route information for future use
	self.current_route = {
		airport1 = self.first_selected_airport,
		airport2 = self.second_selected_airport,
		distance = distance,
		valid_categories = valid_categories,
		eligible_planes = eligible_planes
	}
	
	-- Set popup visible flag
	self.popup_visible = true
	
	-- Show the route popup by sending message to GUI
	msg.post("RoutePopup#RoutePopup", "show_route_popup", {
		airport1 = self.first_selected_airport,
		airport2 = self.second_selected_airport,
		distance = distance,
		valid_categories = valid_categories,
		eligible_planes = eligible_planes
	})
end

-- Function to determine valid plane categories for a route
function get_valid_plane_categories(airport1_category, airport2_category)
	local valid_categories = {}
	
	-- Define which plane categories can use each airport category
	local airport_compatible_planes = {
		[1] = {1, 2},      -- Category 1 airports can handle plane categories 1 or 2
		[2] = {1, 2, 3},   -- Category 2 airports can handle plane categories 1, 2, or 3
		[3] = {2, 3, 4, 5} -- Category 3 airports can handle plane categories 2, 3, 4, or 5
	}
	
	-- Find intersection of plane categories that can use both airports
	for _, cat1 in ipairs(airport_compatible_planes[airport1_category]) do
		for _, cat2 in ipairs(airport_compatible_planes[airport2_category]) do
			if cat1 == cat2 then
				table.insert(valid_categories, cat1)
			end
		end
	end
	
	return valid_categories
end

-- Function to get eligible planes from fleet for this route
function get_eligible_fleet_planes(self, valid_categories, required_range)
	local eligible_planes = {}
	
	-- Check if GAirline_fleet exists
	if not GAirline_fleet then
		return eligible_planes
	end
	
	-- Go through each plane in the fleet
	for _, fleet_entry in ipairs(GAirline_fleet) do
		local plane_index = fleet_entry[1]
		local plane_count = fleet_entry[2]
		
		-- Get the plane details from availability list
		local plane = S_airplaneAvailabilityList[plane_index]
		
		if plane then
			-- Check if this plane's category is valid for the route
			local is_valid_category = false
			for _, cat in ipairs(valid_categories) do
				if plane.planeCat == cat then
					is_valid_category = true
					break
				end
			end
			
			-- Check if the plane's range is sufficient
			local has_sufficient_range = (plane.spec_range and plane.spec_range >= required_range)
			
			-- If plane meets both criteria, add it to eligible planes
			if is_valid_category and has_sufficient_range then
				table.insert(eligible_planes, {
					plane = plane,
					index = plane_index,
					count = plane_count
				})
			end
		end
	end
	
	return eligible_planes
end

-- Function to assign a plane to a route
function assign_plane_to_route(self, plane_data)
	if not self.current_route then
		print("Error: No current route")
		return
	end
	
	-- Create route entry for the airline's routes
	local new_route = {
		from = self.current_route.airport1,
		to = self.current_route.airport2,
		distance = self.current_route.distance,
		plane_index = plane_data.index,
		plane_name = plane_data.plane.planeName
	}
	
	-- Initialize the routes table if it doesn't exist
	if not GAirline_routes then
		GAirline_routes = {}
	end
	
	-- Add the new route to global routes
	table.insert(GAirline_routes, new_route)
	
	-- Add route line to global route lines
	if not GAirline_routelines then
		GAirline_routelines = {}
	end
	
	-- Store route line data
	local route_line_data = {
		pos1 = go.get_position(self.current_route.airport1.id),
		pos2 = go.get_position(self.current_route.airport2.id)
	}
	
	table.insert(GAirline_routelines, route_line_data)
	
	-- Reduce plane count in fleet (assume at least 1 available)
	for i, fleet_entry in ipairs(GAirline_fleet) do
		if fleet_entry[1] == plane_data.index then
			-- Reduce count by 1
			fleet_entry[2] = fleet_entry[2] - 1
			
			-- If no planes of this type left, remove the entry
			if fleet_entry[2] <= 0 then
				table.remove(GAirline_fleet, i)
			end
			
			break
		end
	end
	
	-- Show confirmation message
	print("Route created: " .. self.current_route.airport1.name .. " to " .. 
		self.current_route.airport2.name .. " using " .. plane_data.plane.planeName)
	
	-- Hide popup (handled by GUI)
	self.popup_visible = false
	
	-- Update route visualization
	update_route_lines(self)
end

function on_input(self, action_id, action)
	
	-- Get current rotation
	local rotation = go.get_rotation("Globe#GlobeModel")
	
	-- Use a default delta time if not provided
	if (action.delta_time) then
		dt = action.delta_time
	else
		dt = 1/60
	end

	-- If popup is visible, don't handle input except for when GUI communicates back
	if self.popup_visible then
		return false
	end
	
	-- Handle mouse movement for hover effects (when no action_id is provided)
	if action_id == nil then
		-- Store mouse position
		local mouse_pos = vmath.vector3(action.x, action.y, 0)
		
		-- Track the closest airport and its distance
		local hovered_airport = nil
		local closest_distance = math.huge  -- Start with infinity
		local hover_radius = 50             -- Reasonable hover radius in pixels
		
		-- Check each airport
		for _, airport in ipairs(airportList) do
			-- Get the 3D position of the airport
			local world_pos = go.get_position(airport.id)
			
			-- Project the 3D position to 2D screen space
			local screen_pos = world_to_screen(world_pos)
			
			if screen_pos then
				-- Calculate the distance from mouse to projected airport position
				local distance = vmath.length(vmath.vector3(screen_pos.x - mouse_pos.x, screen_pos.y - mouse_pos.y, 0))
				
				-- If this airport is closer than previous closest and within hover radius
				if distance < closest_distance and distance < hover_radius then
					hovered_airport = airport
					closest_distance = distance
				end
				
				-- Reset hover state for airport if it's not the closest
				if airport.hover and airport ~= hovered_airport and not airport.selected then
					airport.hover = false
					go.set(airport.model, "tint", COLORS.normal)
				end
			end
		end
		
		-- Set hover effect for the closest airport if it's not already selected
		if hovered_airport and not hovered_airport.selected then
			if not hovered_airport.hover then
				hovered_airport.hover = true
				go.set(hovered_airport.model, "tint", COLORS.hover)
			end
		end
	end

	-- Handle mouse click
	if action_id == hash("touch") and action.pressed then
		-- Store mouse position
		local mouse_pos = vmath.vector3(action.x, action.y, 0)
		
		-- Track the closest airport and its distance
		local closest_airport = nil
		local closest_distance = math.huge  -- Start with infinity
		local click_radius = 50             -- Reasonable click radius in pixels
		
		-- Check each airport
		for _, airport in ipairs(airportList) do
			-- Get the 3D position of the airport
			local world_pos = go.get_position(airport.id)
			
			-- Project the 3D position to 2D screen space
			local screen_pos = world_to_screen(world_pos)
			
			if screen_pos then
				-- Calculate the distance from mouse click to projected airport position
				local distance = vmath.length(vmath.vector3(screen_pos.x - mouse_pos.x, screen_pos.y - mouse_pos.y, 0))
				
				-- If this airport is closer than previous closest and within click radius
				if distance < closest_distance and distance < click_radius then
					closest_airport = airport
					closest_distance = distance
				end
			end
		end
		
		-- If we found a close airport, handle selection
		if closest_airport then
			print("Clicked on " .. closest_airport.name)
			
			if not self.first_selected_airport then
				-- First selection
				self.first_selected_airport = closest_airport
				closest_airport.selected = true
				go.set(closest_airport.model, "tint", COLORS.selected)
			elseif self.first_selected_airport == closest_airport then
				-- Deselect if clicking the same airport
				go.set(closest_airport.model, "tint", closest_airport.hover and COLORS.hover or COLORS.normal)
				closest_airport.selected = false
				self.first_selected_airport = nil
			elseif not self.second_selected_airport then
				-- Second selection
				self.second_selected_airport = closest_airport
				closest_airport.selected = true
				go.set(closest_airport.model, "tint", COLORS.second_selected)
				
				-- Show route information when two airports are selected
				show_route_info(self)
			elseif self.second_selected_airport == closest_airport then
				-- Deselect if clicking the same second airport
				go.set(closest_airport.model, "tint", closest_airport.hover and COLORS.hover or COLORS.normal)
				closest_airport.selected = false
				self.second_selected_airport = nil
			else
				-- Clicking a third airport resets selections
				reset_airport_selections(self)
				
				-- Then select the new airport as first selection
				self.first_selected_airport = closest_airport
				closest_airport.selected = true
				go.set(closest_airport.model, "tint", COLORS.selected)
			end
		else
			-- Clicked empty space - reset selections
			reset_airport_selections(self)
		end
	end
	
	-- Handle arrow key input
	if action_id == hash("key_left") then
		-- Screen-relative rotation - use quaternion for Y axis rotation
		local rot = vmath.quat_rotation_y(math.rad(self.rotation_speed * dt))
		go.set_rotation(rot * rotation, "Globe#GlobeModel")
		
		-- Rotate all airports around world origin
		for _, airport in ipairs(airportList) do
			local pos = go.get_position(airport.id)
			local rotated_pos = vmath.rotate(rot, pos)
			go.set_position(rotated_pos, airport.id)
			go.set_rotation(rot * rotation, airport.id)
		end
		
		-- Also rotate any active route lines
		if self.active_route_lines then
			for _, line_id in ipairs(self.active_route_lines) do
				local pos = go.get_position(line_id)
				local rotated_pos = vmath.rotate(rot, pos)
				go.set_position(rotated_pos, line_id)
				go.set_rotation(rot * rotation, line_id)
			end
		end
	elseif action_id == hash("key_right") then
		-- Screen-relative rotation - use quaternion for Y axis rotation (negative)
		local rot = vmath.quat_rotation_y(math.rad(-self.rotation_speed * dt))
		go.set_rotation(rot * rotation, "Globe#GlobeModel")
		
		-- Rotate all airports around world origin
		for _, airport in ipairs(airportList) do
			local pos = go.get_position(airport.id)
			local rotated_pos = vmath.rotate(rot, pos)
			go.set_position(rotated_pos, airport.id)
			go.set_rotation(rot * rotation, airport.id)
		end
		
		-- Also rotate any active route lines
		if self.active_route_lines then
			for _, line_id in ipairs(self.active_route_lines) do
				local pos = go.get_position(line_id)
				local rotated_pos = vmath.rotate(rot, pos)
				go.set_position(rotated_pos, line_id)
				go.set_rotation(rot * rotation, line_id)
			end
		end
	elseif action_id == hash("key_up") then
		-- Screen-relative rotation - use quaternion for X axis rotation
		local rot = vmath.quat_rotation_x(math.rad(-self.rotation_speed * dt))
		go.set_rotation(rot * rotation, "Globe#GlobeModel")
		
		-- Rotate all airports around world origin
		for _, airport in ipairs(airportList) do
			local pos = go.get_position(airport.id)
			local rotated_pos = vmath.rotate(rot, pos)
			go.set_position(rotated_pos, airport.id)
			go.set_rotation(rot * rotation, airport.id)
		end
		
		-- Also rotate any active route lines
		if self.active_route_lines then
			for _, line_id in ipairs(self.active_route_lines) do
				local pos = go.get_position(line_id)
				local rotated_pos = vmath.rotate(rot, pos)
				go.set_position(rotated_pos, line_id)
				go.set_rotation(rot * rotation, line_id)
			end
		end
	elseif action_id == hash("key_down") then
		-- Screen-relative rotation - use quaternion for X axis rotation (negative)
		local rot = vmath.quat_rotation_x(math.rad(self.rotation_speed * dt))
		go.set_rotation(rot * rotation, "Globe#GlobeModel")
		
		-- Rotate all airports around world origin
		for _, airport in ipairs(airportList) do
			local pos = go.get_position(airport.id)
			local rotated_pos = vmath.rotate(rot, pos)
			go.set_position(rotated_pos, airport.id)
			go.set_rotation(rot * rotation, airport.id)
		end
		
		-- Also rotate any active route lines
		if self.active_route_lines then
			for _, line_id in ipairs(self.active_route_lines) do
				local pos = go.get_position(line_id)
				local rotated_pos = vmath.rotate(rot, pos)
				go.set_position(rotated_pos, line_id)
				go.set_rotation(rot * rotation, line_id)
			end
		end
	end
end

-- Function to draw a single route line
function draw_route_line(self, pos1, pos2)
	-- Calculate midpoint between the two positions
	local midpoint = (pos1 + pos2) * 0.5
	
	-- Calculate the direction vector from pos1 to pos2
	local direction = vmath.normalize(pos2 - pos1)
	
	-- Calculate the distance between points (straight line)
	local straight_distance = vmath.length(pos2 - pos1)
	
	-- Create a line object using the factory
	local line_id = factory.create("#line_factory", midpoint)
	
	if line_id then
		-- Calculate the rotation needed to align the line with the direction
		local up = vmath.vector3(0, 1, 0)
		local rotation = vmath.quat_from_to(up, direction)
		
		-- Set the rotation of the line
		go.set_rotation(rotation, line_id)
		
		-- Scale the line according to the distance
		-- Make the line slightly longer to account for curvature
		local scale_factor = 1.1 -- Adjust as needed for visual appearance
		go.set_scale(vmath.vector3(0.05, straight_distance * scale_factor, 0.05), line_id)
		
		-- Set a color for the line
		go.set(line_id, "tint", vmath.vector4(1, 0.8, 0, 0.8)) -- Yellow with some transparency
		
		-- Return the line ID for later reference
		return line_id
	end
	
	return nil
end

-- Function to draw all route lines from global GAirline_routelines
function update_route_lines(self)
	-- Clear any existing route lines
	if self.active_route_lines then
		for _, line_id in ipairs(self.active_route_lines) do
			go.delete(line_id)
		end
	end
	
	-- Initialize the array to track active route lines
	self.active_route_lines = {}
	
	-- If no route lines exist in global data, return
	if not GAirline_routelines or #GAirline_routelines == 0 then
		print("No routes to draw")
		return
	end
	
	-- For each route line, create a series of segments to form a curved path along the globe
	for i, route_line_data in ipairs(GAirline_routelines) do
		local pos1 = route_line_data.pos1
		local pos2 = route_line_data.pos2
		
		-- Get the radius of the globe (assume spherical)
		local globe_radius = vmath.length(pos1)
		
		-- Number of segments to create a smooth route
		local num_segments = 12
		
		-- Create multiple segments to form a curve
		local prev_point = pos1
		
		for j = 1, num_segments do
			-- Calculate the next point along the great circle
			local t = j / num_segments
			
			-- Simple spherical interpolation (slerp-like approach)
			-- Linear interpolation in 3D space
			local raw_point = vmath.vector3(
				pos1.x * (1-t) + pos2.x * t,
				pos1.y * (1-t) + pos2.y * t,
				pos1.z * (1-t) + pos2.z * t
			)
			
			-- Project back onto sphere's surface
			local point = vmath.normalize(raw_point) * globe_radius
			
			-- Skip creating a segment for the first iteration (no previous segment)
			if j > 1 then
				-- Create a line segment from prev_point to point
				local segment_midpoint = (prev_point + point) * 0.5
				
				-- Slightly adjust the midpoint to follow the curve of the globe
				local adjustment_factor = 0.05  -- How much to push outward (0.05 = 5% of globe radius)
				local adjusted_midpoint = vmath.normalize(segment_midpoint) * (globe_radius * (1 + adjustment_factor))
				
				-- Create the line segment
				local segment_id = factory.create("#line_factory", adjusted_midpoint)
				
				if segment_id then
					-- Calculate direction and rotation
					local segment_dir = vmath.normalize(point - prev_point)
					
					-- Calculate rotation to align the line with the direction
					local up = vmath.vector3(0, 1, 0)
					local segment_rot = vmath.quat_from_to(up, segment_dir)
					
					-- Set the rotation
					go.set_rotation(segment_rot, segment_id)
					
					-- Calculate segment length
					local segment_length = vmath.length(point - prev_point)
					
					-- Scale the line
					go.set_scale(vmath.vector3(0.02, segment_length, 0.02), segment_id)
					
					-- Set a bright yellow color for visibility
					go.set(segment_id, "tint", vmath.vector4(1, 0.9, 0, 1))
					
					-- Store for cleanup
					table.insert(self.active_route_lines, segment_id)
				end
			end
			
			-- Update previous point for the next segment
			prev_point = point
		end
	end
	
	print("=== ACTIVE ROUTES ===")
	print("Rendered " .. #self.active_route_lines .. " route line segments")
	print("====================")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("assign_plane") then
		-- Handle plane assignment from popup
		assign_plane_to_route(self, message.plane_data)
	elseif message_id == hash("close_popup") then
		-- Handle popup closure
		self.popup_visible = false
		-- Don't reset selections yet to allow user to choose another plane
	elseif message_id == hash("proxy_loaded") then
		-- Enable the route popup GUI once loaded
		msg.post(sender, "enable")
	end
end

-- Add function to display airport information
function display_airport_info(self, airport)
	if not airport then
		return
	end
	
	-- Just print to console for now
	print("Selected airport: " .. airport.name)
	
	-- You could also display additional info about the airport here
	-- like its position, category, facilities, etc.
end

-- Reset all airport selections
function reset_airport_selections(self)
	-- Reset first selection if exists
	if self.first_selected_airport then
		go.set(self.first_selected_airport.model, "tint", 
			self.first_selected_airport.hover and COLORS.hover or COLORS.normal)
		self.first_selected_airport.selected = false
		self.first_selected_airport = nil
	end
	
	-- Reset second selection if exists
	if self.second_selected_airport then
		go.set(self.second_selected_airport.model, "tint", 
			self.second_selected_airport.hover and COLORS.hover or COLORS.normal)
		self.second_selected_airport.selected = false
		self.second_selected_airport = nil
	end
	
	-- Also remove any route line
	if self.route_line then
		go.delete(self.route_line)
		self.route_line = nil
	end
	
	-- Clear current route
	self.current_route = nil
end